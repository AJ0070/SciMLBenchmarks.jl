---
title: Nonlinear Solver 23 Test Problems
author: Torkel Loman
---

These benchmarks compares the runtime and error for a range of nonlinear solvers. The problems are a standard set of problems as described [here](https://people.sc.fsu.edu/~jburkardt/m_src/test_nonlin/test_nonlin.html). The solvers are implemented in [NonlinearProblemLibrary.jl](https://github.com/SciML/DiffEqProblemLibrary.jl/blob/master/lib/NonlinearProblemLibrary/src/NonlinearProblemLibrary.jl), where you can find the problem function declarations. For each problem we test the following solvers:
- NonlinearSolve.jl's [Newton Raphson](https://docs.sciml.ai/NonlinearSolve/stable/api/nonlinearsolve/#NonlinearSolve.NewtonRaphson) method (`NewtonRaphson()`).
- NonlinearSolve.jl's [Trust Region](https://docs.sciml.ai/NonlinearSolve/stable/api/nonlinearsolve/#NonlinearSolve.TrustRegion) method (`TrustRegion()`).
- NonlinearSolve.jl's Levenberg-Marquardt method (`LevenbergMarquardt()`).
- MINPACK's [Modified Powell](https://docs.sciml.ai/NonlinearSolve/stable/api/minpack/#NonlinearSolveMINPACK.CMINPACK) method (`CMINPACK(method=:hybr)`).
- MINPACK's [Levenberg-Marquardt](https://docs.sciml.ai/NonlinearSolve/stable/api/minpack/#NonlinearSolveMINPACK.CMINPACK) method (`CMINPACK(method=:lm)`).
- NLsolveJL's [Newton Raphson](https://docs.sciml.ai/NonlinearSolve/stable/api/nlsolve/#Solver-API) (`NLsolveJL(method=:newton)`).
- NLsolveJL's [Trust Region](https://docs.sciml.ai/NonlinearSolve/stable/api/nlsolve/#Solver-API) (`NLsolveJL()`).
- NLsolveJL's [Anderson acceleration](https://docs.sciml.ai/NonlinearSolve/stable/api/nlsolve/#Solver-API) (`NLsolveJL(method=:anderson)`).
- Sundials's [Newton-Krylov](https://docs.sciml.ai/NonlinearSolve/stable/api/sundials/#Solver-API) method (`KINSOL()`).

Furthermore, for NonlinearSolve.jl's Newton Raphson method we try the following Line Search options (in addition to the default):
- `HagerZhang`
- `MoreThuente`
- `BackTracking`

and for NonlinearSolve.jl's Trust Region we try the following Radius Update schemes (in addition to the default):
- `NLsolve` 
- `NocedalWright` 
- `Hei` 
- `Yuan` 
- `Bastin` 
- `Fan` 
and finally for NonlinearSolve.jl's Levenberg-Marquardt method why try using both the default `α_geodesic` value (`0.75`) and a modified value (`0.5`), and also with and without setting the `CholeskyFactorization` linear solver.

For each benchmarked problem, the second, third, and fourth plots compares the performance of NonlinearSolve's Newton Raphson, Trust Region, and Levenberg-Marquardt methods, respectively. The first plot compares the best methods from each of these categories to the various methods available from other packages. At the end of the benchmarks, we print a summary table of which solvers succeeded for which problems.

# Setup

Fetch required packages.

```julia
using NonlinearSolve, MINPACK, NLsolve, LinearSolve, StaticArrays, Sundials, Setfield,
    BenchmarkTools, LinearAlgebra, DiffEqDevTools, NonlinearProblemLibrary, CairoMakie
RUS = RadiusUpdateSchemes;
```

Declare the benchmarked solvers (and their names and plotting options).

```julia
solvers_all = [ 
    (; pkg = :nonlinearsolve, type = :NR,      name = "Newton Raphson (No Line Search)",                        solver = Dict(:alg=>NewtonRaphson(; linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :NR,      name = "Newton Raphson (Hager & Zhang Line Search)",             solver = Dict(:alg=>NewtonRaphson(; linesearch = HagerZhang(), linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :NR,      name = "Newton Raphson (More & Thuente Line Search)",            solver = Dict(:alg=>NewtonRaphson(; linesearch = MoreThuente(), linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :NR,      name = "Newton Raphson (BackTracking Line Search)",              solver = Dict(:alg=>NewtonRaphson(; linesearch = BackTracking(), linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :TR,      name = "Trust Region",                                           solver = Dict(:alg=>TrustRegion(; linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :TR,      name = "Trust Region (NLsolve Radius Update)",                   solver = Dict(:alg=>TrustRegion(; radius_update_scheme = RUS.NLsolve, linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :TR,      name = "Trust Region (Nocedal Wright Radius Update)",            solver = Dict(:alg=>TrustRegion(; radius_update_scheme = RUS.NocedalWright, linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :TR,      name = "Trust Region (Hei Radius Update)",                       solver = Dict(:alg=>TrustRegion(; radius_update_scheme = RUS.Hei, linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :TR,      name = "Trust Region (Yuan Radius Update)",                      solver = Dict(:alg=>TrustRegion(; radius_update_scheme = RUS.Yuan, linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :TR,      name = "Trust Region (Bastin Radius Update)",                    solver = Dict(:alg=>TrustRegion(; radius_update_scheme = RUS.Bastin, linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :TR,      name = "Trust Region (Fan Radius Update)",                       solver = Dict(:alg=>TrustRegion(; radius_update_scheme = RUS.Fan, linsolve = LUFactorization()))),
    (; pkg = :nonlinearsolve, type = :LM,      name = "Levenberg-Marquardt (α_geodesic=0.75)",                  solver = Dict(:alg=>LevenbergMarquardt(; linsolve = QRFactorization()))),
    (; pkg = :nonlinearsolve, type = :LM,      name = "Levenberg-Marquardt (α_geodesic=0.75, with Cholesky)",   solver = Dict(:alg=>LevenbergMarquardt(; linsolve = CholeskyFactorization()))),
    (; pkg = :nonlinearsolve, type = :LM,      name = "Levenberg-Marquardt (α_geodesic=0.5)",                   solver = Dict(:alg=>LevenbergMarquardt(; linsolve = QRFactorization(), α_geodesic=0.5))),
    (; pkg = :nonlinearsolve, type = :LM,      name = "Levenberg-Marquardt (α_geodesic=0.5, with Cholesky)",    solver = Dict(:alg=>LevenbergMarquardt(; linsolve = CholeskyFactorization(), α_geodesic=0.5))),
    (; pkg = :nonlinearsolve, type = :LM,      name = "Levenberg-Marquardt (no Geodesic Accln.)",               solver = Dict(:alg=>LevenbergMarquardt(; disable_geodesic = Val(true)))),
    (; pkg = :nonlinearsolve, type = :LM,      name = "Levenberg-Marquardt (no Geodesic Accln. with Cholesky)",  solver = Dict(:alg=>LevenbergMarquardt(; linsolve = CholeskyFactorization(), disable_geodesic = Val(true)))),
    (; pkg = :wrapper,        type = :general, name = "PseudoTransient (alpha_initial=10.0)",                   solver = Dict(:alg=>PseudoTransient(; linsolve = LUFactorization(), alpha_initial=10.0))),
    (; pkg = :wrapper,        type = :general, name = "Modified Powell (CMINPACK)",                             solver = Dict(:alg=>CMINPACK(; method=:hybr))),
    (; pkg = :wrapper,        type = :general, name = "Levenberg-Marquardt (CMINPACK)",                         solver = Dict(:alg=>CMINPACK(; method=:lm))),
    (; pkg = :wrapper,        type = :general, name = "Newton Raphson (NLsolveJL)",                             solver = Dict(:alg=>NLsolveJL(; method=:newton))),
    (; pkg = :wrapper,        type = :general, name = "Trust Region (NLsolveJL)",                               solver = Dict(:alg=>NLsolveJL())),
    (; pkg = :wrapper,        type = :general, name = "Newton Raphson (Sundials)",                              solver = Dict(:alg=>KINSOL()))
];
solver_tracker = [];
```

Sets tolerances.

```julia
abstols = 1.0 ./ 10.0 .^ (4:12)
reltols = 1.0 ./ 10.0 .^ (4:12);
```

Prepares various helper functions for benchmarking a specific problem.

```julia
function set_ad_chunksize(solvers, u0)
    ck = min(NonlinearSolve.pickchunksize(u0), 6)
    for i in 1:length(solvers)
        @set! solvers[i].solver[:alg] = __set_ad_chunksize(solvers[i].solver[:alg], ck)
    end
    return solvers
end

function __set_ad_chunksize(solver::GeneralizedFirstOrderAlgorithm{CJ, N}, ck) where {CJ, N}
    ad = AutoForwardDiff(; chunksize = ck)
    return GeneralizedFirstOrderAlgorithm{CJ, N}(; solver.descent, solver.linesearch,
        solver.trustregion, jacobian_ad = ad, solver.max_shrink_times, solver.forward_ad,
        solver.reverse_ad)
end
__set_ad_chunksize(solver, ck) = solver

# Benchmarks a specific problem, checks which solvers can solve it and their performance
function benchmark_problem!(prob_name; solver_tracker=solver_tracker, selected_NR=nothing,
        selected_TR=nothing, selected_LM=nothing)
    # Finds the problem and the true solution.
    prob = nlprob_23_testcases[prob_name]

    # Finds the solvers that can solve the problem
    solvers_concrete = set_ad_chunksize(solvers_all, prob.prob.u0)
    successful_solvers = filter(solver -> check_solver(prob, solver), solvers_concrete)
    push!(solver_tracker, prob_name => successful_solvers)

    # Handles the non-general cases.
    solvers_NR = filter(s -> s.type==:NR, successful_solvers)
    solvers_TR = filter(s -> s.type==:TR, successful_solvers)
    solvers_LM = filter(s -> s.type==:LM, successful_solvers)
    wp_NR = WorkPrecisionSet(prob.prob, abstols, reltols, getfield.(solvers_NR, :solver);
        names=getfield.(solvers_NR, :name), numruns=100, error_estimate=:l∞,
        maxiters=10000, termination_condition = AbsNormTerminationMode())
    wp_TR = WorkPrecisionSet(prob.prob, abstols, reltols, getfield.(solvers_TR, :solver);
        names=getfield.(solvers_TR, :name), numruns=100, error_estimate=:l∞,
        maxiters=10000, termination_condition = AbsNormTerminationMode())
    wp_LM = WorkPrecisionSet(prob.prob, abstols, reltols, getfield.(solvers_LM, :solver);
        names=getfield.(solvers_LM, :name), numruns=100, error_estimate=:l∞,
        maxiters=10000, termination_condition = AbsNormTerminationMode())

    # Handles the general case
    solvers_general = filter(s -> s.type==:general, successful_solvers)
    add_solver!(solvers_general, selected_TR, solvers_TR, wp_TR)
    add_solver!(solvers_general, selected_LM, solvers_LM, wp_LM)
    add_solver!(solvers_general, selected_NR, solvers_NR, wp_NR)

    wp_general = WorkPrecisionSet(prob.prob, abstols, reltols,
        getfield.(solvers_general, :solver); names=getfield.(solvers_general, :name),
        numruns=100, error_estimate=:l∞, maxiters=10000)
    
    xlimit, ylimit, xticks, yticks = get_limits_and_ticks(wp_general, wp_NR, wp_TR, wp_LM)
    wp_plot_general = plot_wp(wp_general, solvers_general, xguide="", xlimit, ylimit,
        linewidth=7, true, xticks=(xticks, fill("", length(xticks))), yticks=yticks)
    wp_plot_NR = plot_wp(wp_NR, solvers_NR, xlimit, ylimit, linewidth=7, true; xguide="",
        yguide="", xticks=(xticks, fill("", length(xticks))),
        yticks=(yticks, fill("", length(yticks))), right_margin=7mm)
    wp_plot_TR = plot_wp(wp_TR, solvers_TR, xlimit, ylimit, linewidth=7, false;
        xticks=xticks, yticks=yticks)
    wp_plot_LM = plot_wp(wp_LM, solvers_LM, xlimit, ylimit, linewidth=7, false; yguide="",
        xticks=xticks, yticks=(yticks, fill("", length(yticks))), right_margin=7mm)
    plot(wp_plot_general, wp_plot_NR, wp_plot_TR, wp_plot_LM, layout=(2,2),
        size=(1600,2100), left_margin=12mm)
end

# Checks if a solver can successfully solve a given problem.
function check_solver(prob, solver)
    try
        sol = solve(prob.prob, solver.solver[:alg]; abstol=1e-8, reltol=1e-8,
            maxiters=10000000, termination_condition=AbsNormTerminationMode())
        if norm(sol.resid, Inf) < 1e-6
            Base.printstyled("[Info] Solver $(solver.name) returned retcode $(sol.retcode) with an residual norm = $(norm(sol.resid, Inf)).\n"; color=:green)
            return true
        else
            Base.printstyled("[Warn] Solver $(solver.name) had a very large residual (norm = $(norm(sol.resid, Inf))).\n"; color=:red)
            return false
        end
        WorkPrecisionSet(prob.prob, [1e-4, 1e-12], [1e-4, 1e-12], [solver.solver]; names=[solver.name], numruns=100, error_estimate=:l∞, maxiters=10000000)
    catch e
        Base.printstyled("[Warn] Solver $(solver.name) threw an error: $e.\n"; color=:red)    
        return false
    end
    return true
end

# Adds an additional, selected, solver to the general solver set.
# Adds an additional, selected, solver to the general solver set.
function add_solver!(solvers_general, selected_solver_name, additional_solver_set, wp)
    if isnothing(selected_solver_name)
        isempty(wp.wps) && return
        selected_idx = argmin(median.(getfield.(wp.wps, :times))) 
    else
        selected_idx = findfirst(s -> s.name==selected_solver_name, additional_solver_set)
        isnothing(selected_solver) && error("The $(selected_solver_name) was designated to be added to the general solver set, however, it seemed to fail on this problem.")
    end
    isnothing(selected_idx) || pushfirst!(solvers_general, additional_solver_set[selected_idx])   
end;
```

Plotting related helper functions.

```julia
# Plots a work-precision diagram.
function plot_wp(wp, selected_solvers, xlimit, ylimit, top; kwargs...)
    color = reshape(getfield.(selected_solvers, :color),1,length(selected_solvers))
    markershape = reshape(getfield.(selected_solvers, :markershape),1,length(selected_solvers))

    if isempty(wp.wps)
        (:xguide in keys(kwargs)) || (kwargs = (; xguide="Error", kwargs...))
        (:yguide in keys(kwargs)) || (kwargs = (; yguide="Time (s)", kwargs...))
        plt = plot(;xlimit=xlimit, ylimit=ylimit, legend=:none, xaxis=:log10, yaxis=:log10, kwargs...)
        if top
            plt_legend = plot(;xlimit=(1e6,1e6+1), ylimit=(0.01,0.011), legend=:outerbottom, axis=false, grid=false, framestyle=:none, margin=0mm, kwargs...)
            return plot(plt_legend, plt, layout = grid(2, 1, heights=[0.25, 0.75]), top_margin=0mm, bottom_margin=0mm)
        else
            plt_legend = plot(;xlimit=(1e6,1e6+1), ylimit=(0.01,0.011), legend=:outertop, axis=false, grid=false, framestyle=:none, margin=0mm, kwargs...)
            return plot(plt, plt_legend, layout = grid(2, 1, heights=[0.75, 0.25]), top_margin=0mm, bottom_margin=0mm)
        end
    end
    plt = plot(wp; color=color, markershape=markershape, xlimit=xlimit, ylimit=ylimit, legend=:none, kwargs...)
    if top
        plt_legend = plot(wp; color=color, markershape=markershape, xlimit=(1e6,1e6+1), ylimit=(0.01,0.011), legend=:outerbottom, axis=false, grid=false, framestyle=:none, margin=0mm, kwargs...)
        return plot(plt_legend, plt, layout = grid(2, 1, heights=[0.25, 0.75]), top_margin=0mm, bottom_margin=0mm)
    else
        plt_legend = plot(wp; color=color, markershape=markershape, xlimit=(1e6,1e6+1), ylimit=(0.01,0.011), legend=:outertop, axis=false, grid=false, framestyle=:none, margin=0mm, kwargs...)
        return plot(plt, plt_legend, layout = grid(2, 1, heights=[0.75, 0.25]), top_margin=0mm, bottom_margin=0mm)
    end
end

# For a set of wp diaggras, get ticks and limits.
function get_limits_and_ticks(args...)
    xlimit = [Inf, -Inf]
    ylimit = [Inf, -Inf]
    for wp in args
        isempty(wp.wps) && continue
        xlim, ylim = xy_limits(wp)
        (xlimit[1] > xlim[1]) && (xlimit[1] = xlim[1])
        (xlimit[2] < xlim[2]) && (xlimit[2] = xlim[2])
        (ylimit[1] > ylim[1]) && (ylimit[1] = ylim[1])
        (ylimit[2] < ylim[2]) && (ylimit[2] = ylim[2])
    end
    xlimit = Tuple(xlimit)
    ylimit = Tuple(ylimit)
    xticks = get_ticks(xlimit)
    yticks = get_ticks(ylimit)
    return xlimit, ylimit, xticks, yticks 
end

# Finds good x and y limits for a work precision diagram.
function xy_limits(wp)
    times = vcat(map(wp -> wp.times, wp.wps)...)
    errors = vcat(map(wp -> wp.errors.l∞, wp.wps)...)
    xlimit = 10 .^ (floor(log10(minimum(errors))), ceil(log10(maximum(errors))))
    ylimit = 10 .^ (floor(log10(minimum(times))), ceil(log10(maximum(times))))
    return xlimit, ylimit
end

# Finds good x and y ticks for a work precision diagram.
function arithmetic_sequences(v1, v2)
    sequences = []
    for n in 2:(v2-v1+1)
        d = (v2 - v1) / (n - 1)
        if d == floor(d)  
            sequence = [v1 + (j-1)*d for j in 1:n]
            push!(sequences, sequence)
        end
    end
    return sequences
end

function get_ticks(limit)
    (limit == (Inf, -Inf)) && (return [])
    limit = log10.(limit)
    (limit[1]==-Inf) && return 10.0 .^[limit[1], limit[2]]
    sequences = arithmetic_sequences(limit...)
    selected_seq = findlast(length.(sequences) .< 5)
    if length(sequences[selected_seq]) < 4
        step = (limit[2] - limit[1]) / 6.0
        ticks = [round(Int, limit[1] + i*step) for i in 1:5]
        return 10 .^[limit[1];ticks;limit[2]]
    end
    return 10 .^sequences[selected_seq]
end;
```

# Benchmarks

We here run benchmarks for each of the 23 models. 

### Problem 1 (Generalized Rosenbrock function)

```julia
benchmark_problem!("Generalized Rosenbrock function")
```

```julia
# Testing
prob_name = "Generalized Rosenbrock function"
prob = nlprob_23_testcases[prob_name]

# Finds the solvers that can solve the problem
solvers_concrete = set_ad_chunksize(solvers_all, prob.prob.u0);
successful_solvers = filter(solver -> check_solver(prob, solver), solvers_concrete);
solver_tracker_2 = []
push!(solver_tracker_2, prob_name => successful_solvers);

# Handles the non-general cases.
solvers_NR = filter(s -> s.type==:NR, successful_solvers)
solvers_TR = filter(s -> s.type==:TR, successful_solvers)
solvers_LM = filter(s -> s.type==:LM, successful_solvers)
wp_NR = WorkPrecisionSet(prob.prob, abstols, reltols, getfield.(solvers_NR, :solver);
    names=getfield.(solvers_NR, :name), numruns=100, error_estimate=:l∞,
    maxiters=10000, termination_condition = AbsNormTerminationMode())
wp_TR = WorkPrecisionSet(prob.prob, abstols, reltols, getfield.(solvers_TR, :solver);
    names=getfield.(solvers_TR, :name), numruns=100, error_estimate=:l∞,
    maxiters=10000, termination_condition = AbsNormTerminationMode())
wp_LM = WorkPrecisionSet(prob.prob, abstols, reltols, getfield.(solvers_LM, :solver);
    names=getfield.(solvers_LM, :name), numruns=100, error_estimate=:l∞,
    maxiters=10000, termination_condition = AbsNormTerminationMode())

# Handles the general case
solvers_general = filter(s -> s.type==:general, successful_solvers)
add_solver!(solvers_general, nothing, solvers_TR, wp_TR)
add_solver!(solvers_general, nothing, solvers_LM, wp_LM)
add_solver!(solvers_general, nothing, solvers_NR, wp_NR)

wp_general = WorkPrecisionSet(prob.prob, abstols, reltols,
    getfield.(solvers_general, :solver); names=getfield.(solvers_general, :name),
    numruns=100, error_estimate=:l∞, maxiters=10000)

xlimit, ylimit, xticks, yticks = get_limits_and_ticks(wp_general, wp_NR, wp_TR, wp_LM)
wp_plot_general = plot_wp(wp_general, solvers_general, xguide="", xlimit, ylimit,
    linewidth=7, true, xticks=(xticks, fill("", length(xticks))), yticks=yticks)
wp_plot_NR = plot_wp(wp_NR, solvers_NR, xlimit, ylimit, linewidth=7, true; xguide="",
    yguide="", xticks=(xticks, fill("", length(xticks))),
    yticks=(yticks, fill("", length(yticks))), right_margin=7mm)
wp_plot_TR = plot_wp(wp_TR, solvers_TR, xlimit, ylimit, linewidth=7, false;
    xticks=xticks, yticks=yticks)
wp_plot_LM = plot_wp(wp_LM, solvers_LM, xlimit, ylimit, linewidth=7, false; yguide="",
    xticks=xticks, yticks=(yticks, fill("", length(yticks))), right_margin=7mm)
plot(wp_plot_general, wp_plot_NR, wp_plot_TR, wp_plot_LM, layout=(2,2),
    size=(1600,2100), left_margin=12mm)
```

### Problem 2 (Powell singular function)

```julia
benchmark_problem!("Powell singular function")
```

### Problem 3 (Powell badly scaled function)

```julia
benchmark_problem!("Powell badly scaled function")
```

### Problem 4 (Wood function)

```julia
benchmark_problem!("Wood function")
```

### Problem 5 (Helical valley function)

```julia
benchmark_problem!("Helical valley function")
```

### Problem 6 (Watson function)

```julia
benchmark_problem!("Watson function")
```

### Problem 7 (Chebyquad function)

```julia
benchmark_problem!("Chebyquad function")
```

### Problem 8 (Brown almost linear function)

```julia
benchmark_problem!("Brown almost linear function")
```

### Problem 9 (Discrete boundary value function)

```julia
benchmark_problem!("Discrete boundary value function")
```

### Problem 10 (Discrete integral equation function)

```julia
benchmark_problem!("Discrete integral equation function")
```

### Problem 11 (Trigonometric function)

```julia
benchmark_problem!("Trigonometric function")
```

### Problem 12 (Variably dimensioned function)

```julia
benchmark_problem!("Variably dimensioned function")
```

### Problem 13 (Broyden tridiagonal function)

```julia
benchmark_problem!("Broyden tridiagonal function")
```

### Problem 14 (Broyden banded function)

```julia
benchmark_problem!("Broyden banded function")
```

### Problem 15 (Hammarling 2 by 2 matrix square root problem)

```julia
benchmark_problem!("Hammarling 2 by 2 matrix square root problem")
```

### Problem 16 (Hammarling 3 by 3 matrix square root problem)

```julia
benchmark_problem!("Hammarling 3 by 3 matrix square root problem")
```

### Problem 17 (Dennis and Schnabel 2 by 2 example)

```julia
benchmark_problem!("Dennis and Schnabel 2 by 2 example")
```

### Problem 18 (Sample problem 18)

```julia
benchmark_problem!("Sample problem 18")
```

### Problem 19 (Sample problem 19)

```julia
benchmark_problem!("Sample problem 19")
```

### Problem 20 (Scalar problem f(x) = x(x - 5)^2)

```julia
benchmark_problem!("Scalar problem f(x) = x(x - 5)^2")
```

### Problem 21 (Freudenstein-Roth function)

```julia
benchmark_problem!("Freudenstein-Roth function")
```

### Problem 22 (Boggs function)

```julia
benchmark_problem!("Boggs function")
```

### Problem 23 (Chandrasekhar function)

```julia
benchmark_problem!("Chandrasekhar function")
```

## Summary of successful solvers

Finally, we print a summary of which solvers successfully solved which problems.

```julia
solver_successes = [(solver in prob[2]) ? "O" : "X" for prob in solver_tracker, solver in solvers_all];
total_successes = [sum(solver_successes[:,i] .== "O") for i in 1:length(solvers_all)]
solver_outcomes = vcat(total_successes', solver_successes);
```

```julia; wrap = false; results = "md2html"
using PrettyTables
io = IOBuffer()
println(io, "```@raw html")
pretty_table(io, solver_outcomes; backend = Val(:html), header = getfield.(solvers_all, :name), alignment=:c)
println(io, "```")
Text(String(take!(io)))
```

# Appendix
```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
