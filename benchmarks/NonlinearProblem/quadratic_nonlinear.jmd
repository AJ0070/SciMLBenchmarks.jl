---
title: Quadratic Nonlinear Rootfinding Benchmark
author: Avik Pal
---

This is a test of a simple small nonlinear rootfinding problem.

```julia
using NonlinearSolve, StaticArrays, DiffEqDevTools, Sundials, CairoMakie, LinearSolve,
    LinearAlgebra, LoopVectorization, StableRNGs
import PolyesterForwardDiff
import MINPACK, NLsolve, SpeedMapping

f_oop(u, p) = u .* u .- p

function f_iip(du, u, p)
    @turbo for i in eachindex(u)
        du[i] = u[i] * u[i] - p
    end
end

function generate_prob(::Val{N}, ::Val{static}) where {N, static}
    # u0_ = rand(StableRNG(0), N)
    u0_ = ones(N)
    u0 = static ? SVector{N, Float64}(u0_) : u0_
    prob = static ? NonlinearProblem{false}(f_oop, u0, 2.0) :
           NonlinearProblem{true}(f_iip, u0, 2.0)
    return prob
end
```

List of Solvers to Benchmark:

```julia
solvers = [
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleNewtonRaphson(; autodiff = AutoFiniteDiff())), name = "SimpleNewtonRaphson (FiniteDiff)"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleTrustRegion(; autodiff = AutoFiniteDiff())), name = "SimpleTrustRegion (FiniteDiff)"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleNewtonRaphson()), name = "SimpleNewtonRaphson (Polyester)"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleTrustRegion()), name = "SimpleTrustRegion (Polyester)"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleNewtonRaphson(; autodiff = AutoForwardDiff())), name = "SimpleNewtonRaphson"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleTrustRegion(; autodiff = AutoForwardDiff())), name = "SimpleTrustRegion"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleKlement()), name = "SimpleKlement"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleDFSane()), name = "SimpleDFSane"),
    (; type = :simplenonlinearsolve, solver = Dict(:alg => SimpleBroyden()), name = "SimpleBroyden"),
    (; type = :nonlinearsolve, solver = Dict(:alg => NewtonRaphson(; autodiff = AutoFiniteDiff())), name = "NewtonRaphson (FiniteDiff)"),
    (; type = :nonlinearsolve, solver = Dict(:alg => TrustRegion(; autodiff = AutoFiniteDiff())), name = "TrustRegion (FiniteDiff)"),
    (; type = :nonlinearsolve, solver = Dict(:alg => NewtonRaphson()), name = "NewtonRaphson"),
    (; type = :nonlinearsolve, solver = Dict(:alg => TrustRegion()), name = "TrustRegion"),
    (; type = :nonlinearsolve, solver = Dict(:alg => Broyden()), name = "Broyden"),
    (; type = :nonlinearsolve, solver = Dict(:alg => Klement()), name = "Klement"),
    (; type = :nonlinearsolve, solver = Dict(:alg => DFSane()), name = "DFSane"),
    (; type = :others, solver = Dict(:alg => KINSOL()), name = "Sundials: KINSOL"),
    (; type = :others, solver = Dict(:alg => CMINPACK(; method = :lm)), name = "MINPACK: Levenberg-Marquardt"),
    (; type = :others, solver = Dict(:alg => CMINPACK(; method = :hybr)), name = "MINPACK: Modified Powell"),
    (; type = :others, solver = Dict(:alg => SpeedMappingJL()), name = "SpeedMapping.jl: speedmapping"),
    (; type = :others, solver = Dict(:alg => NLsolveJL(; autodiff = :forward)), name = "NLsolve: TrustRegion"),
    (; type = :others, solver = Dict(:alg => NLsolveJL()), name = "NLsolve: TrustRegion (FiniteDiff)"),
]
```

Configurations:

```julia
abstols = 1.0 ./ 10.0 .^ (3:2:12)
reltols = 1.0 ./ 10.0 .^ (3:2:12)
```

Helper Functions:

```julia
function check_solver(prob, solver)
    try
        sol = solve(prob, solver.solver[:alg]; abstol = 1e-5, reltol = 1e-5,
            maxiters = 10000)
        err = norm(sol.resid)
        if !SciMLBase.successful_retcode(sol.retcode)
            Base.printstyled("[Warn] Solver $(solver.name) returned retcode $(sol.retcode) with an residual norm = $(norm(sol.resid)).\n";
                color = :red)
            return false
        elseif err > 1e3
            Base.printstyled("[Warn] Solver $(solver.name) had a very large residual (norm = $(norm(sol.resid))).\n";
                color = :red)
            return false
        elseif isinf(err) || isnan(err)
            Base.printstyled("[Warn] Solver $(solver.name) had a residual of $(err).\n";
                color = :red)
            return false
        end
        Base.printstyled("[Info] Solver $(solver.name) successfully solved the problem (norm = $(norm(sol.resid))).\n";
            color = :green)
    catch e
        Base.printstyled("[Warn] Solver $(solver.name) threw an error: $e.\n"; color = :red)
        return false
    end
    return true
end

function generate_wpset(prob, solvers)
    successful_solvers = filter(solver -> check_solver(prob, solver), solvers)
    return WorkPrecisionSet(prob, abstols, reltols, getfield.(successful_solvers, :solver);
        numruns = 50, error_estimate = :l∞, names = getfield.(successful_solvers, :name),
        maxiters = 10000), successful_solvers
end
```

Plotting Functions:

```julia
function plot_wpset(wpset, successful_solvers, title)
    cycle = Cycle([:color, :marker], covary = true)
    theme = merge(theme_latexfonts(), Theme(Lines = (cycle = cycle,),
        Scatter = (cycle = cycle,)))

    linestyle = Dict(:simplenonlinearsolve => :solid, :nonlinearsolve => :dash,
        :others => :dot)

    fig = with_theme(theme; fontsize = 32) do 
        fig = Figure(; size = (1400, 1200))
        ax = Axis(fig[1, 1]; ylabel = L"Time ($s$)", title, xscale = log10, yscale = log10,
            xlabel = L"Error: $f(u^\ast)$ $L_{\infty}$-norm")

        ls, scs = [], []
        
        for (wp, solver) in zip(wpset.wps, successful_solvers)
            (; name, times, errors) = wp
            errors = [err.l∞ for err in errors]
            l = lines!(ax, errors, times; label = name, linewidth = 3, linestyle = linestyle[solver.type])
            sc = scatter!(ax, errors, times; label = name, markersize = 16, strokewidth = 3)
            push!(ls, l)
            push!(scs, sc)
        end

        Legend(fig[2, 1], [[l, sc] for (l, sc) in zip(ls, scs)],
            [solver.name for solver in successful_solvers], position = :ct, color = :white,
            framevisible=false, label = "Solvers", orientation = :horizontal,
            tellwidth = false, tellheight = true, nbanks = 6, labelsize = 20)

        fig
    end

    return fig
end
```

## Static Array Versions

### N = 2

```julia
prob = generate_prob(Val(2), Val(true))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 2")
```

### N = 4

```julia
prob = generate_prob(Val(4), Val(true))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 4")
```

### N = 8

```julia
prob = generate_prob(Val(8), Val(true))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 8")
```

### N = 10

```julia
prob = generate_prob(Val(10), Val(true))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 10")
```

## Julia Arrays

### N = 2

```julia
prob = generate_prob(Val(2), Val(false))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 2")
```

### N = 8

```julia
prob = generate_prob(Val(8), Val(false))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 8")
```

### N = 32

```julia
prob = generate_prob(Val(32), Val(false))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 32")
```

### N = 128

```julia
prob = generate_prob(Val(128), Val(false))
wpset, successful_solvers = generate_wpset(prob, solvers);
fig = plot_wpset(wpset, successful_solvers, "N = 128")
```

## Appendix

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
