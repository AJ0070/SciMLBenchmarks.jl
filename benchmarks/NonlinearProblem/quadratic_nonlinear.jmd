---
title: Quadratic Nonlinear Rootfinding Benchmark
author: Avik Pal
---

This is a test of a simple small nonlinear rootfinding problem.

```julia
using NonlinearSolve, StaticArrays, DiffEqDevTools, Sundials, CairoMakie, LinearSolve,
    LinearAlgebra, LoopVectorization, StableRNGs
import PolyesterForwardDiff, MINPACK, NLsolve, SpeedMapping
RUS = RadiusUpdateSchemes;

f_oop(u, p) = u .* u .- p

function f_iip(du, u, p)
    @turbo for i in eachindex(u)
        du[i] = u[i] * u[i] - p
    end
end

function generate_prob(::Val{N}, ::Val{static}) where {N, static}
    u0_ = ones(N) .+ randn(StableRNG(0), N) * 0.01
    u0 = static ? SVector{N, Float64}(u0_) : u0_
    prob = static ? NonlinearProblem{false}(f_oop, u0, 2.0) :
           NonlinearProblem{true}(f_iip, u0, 2.0)
    return prob
end
```

List of Solvers to Benchmark:

```julia
solvers = [
    (; pkg = :nonlinearsolve,       name = "Default PolyAlgorithm",                              solver = Dict(:alg => nothing)),
    (; pkg = :simplenonlinearsolve, name = "Simple Newton Raphson -- FiniteDiff",                solver = Dict(:alg => SimpleNewtonRaphson(; autodiff = AutoFiniteDiff()))),
    (; pkg = :simplenonlinearsolve, name = "Simple Trust Region -- FiniteDiff",                  solver = Dict(:alg => SimpleTrustRegion(; autodiff = AutoFiniteDiff()))),
    (; pkg = :simplenonlinearsolve, name = "Simple Newton Raphson",                              solver = Dict(:alg => SimpleNewtonRaphson())),
    (; pkg = :simplenonlinearsolve, name = "Simple Trust Region",                                solver = Dict(:alg => SimpleTrustRegion())),
    (; pkg = :simplenonlinearsolve, name = "Simple Klement",                                     solver = Dict(:alg => SimpleKlement())),
    (; pkg = :simplenonlinearsolve, name = "Simple Broyden",                                     solver = Dict(:alg => SimpleBroyden())),
    (; pkg = :simplenonlinearsolve, name = "Simple DFSane",                                      solver = Dict(:alg => SimpleDFSane())),
    (; pkg = :nonlinearsolve,       name = "Newton Raphson",                                     solver = Dict(:alg => NewtonRaphson())),
    (; pkg = :nonlinearsolve,       name = "DFSane",                                             solver = Dict(:alg => DFSane())),
    (; pkg = :nonlinearsolve,       name = "Trust Region",                                       solver = Dict(:alg => TrustRegion())),
    (; pkg = :nonlinearsolve,       name = "Trust Region (NLsolve Update)",                      solver = Dict(:alg => TrustRegion(; radius_update_scheme = RUS.NLsolve))),
    (; pkg = :nonlinearsolve,       name = "Broyden",                                            solver = Dict(:alg => Broyden())),
    (; pkg = :nonlinearsolve,       name = "Klement",                                            solver = Dict(:alg => Klement())),
    (; pkg = :nonlinearsolve,       name = "Levenberg-Marquardt ",                               solver = Dict(:alg => LevenbergMarquardt())),
    (; pkg = :nonlinearsolve,       name = "Levenberg-Marquardt with Cholesky",                  solver = Dict(:alg => LevenbergMarquardt(linsolve = CholeskyFactorization()))),
    (; pkg = :wrapper,              name = "Modified Powell (MINPACK)",                          solver = Dict(:alg => CMINPACK(; method = :hybr))),
    (; pkg = :wrapper,              name = "Levenberg-Marquardt (MINPACK)",                      solver = Dict(:alg => CMINPACK(; method = :lm))),
    (; pkg = :wrapper,              name = "Newton Raphson (NLsolve.jl)",                        solver = Dict(:alg => NLsolveJL(; method = :newton, autodiff = :forward))),
    (; pkg = :wrapper,              name = "Trust Region (NLsolve.jl)",                          solver = Dict(:alg => NLsolveJL(; autodiff = :forward))),
    (; pkg = :wrapper,              name = "Newton Raphson (Sundials)",                          solver = Dict(:alg => KINSOL())),
    (; pkg = :wrapper,              name = "Speed Mapping (SpeedMapping.jl)",                    solver = Dict(:alg => SpeedMappingJL())),
    (; pkg = :nonlinearsolve,       name = "Newton Raphson -- SparseForwardDiff",                solver = Dict(:alg => NewtonRaphson(; autodiff = AutoSparseForwardDiff()))),
    (; pkg = :nonlinearsolve,       name = "Newton Raphson -- SparseFiniteDiff",                 solver = Dict(:alg => NewtonRaphson(; autodiff = AutoSparseFiniteDiff()))),
];
```

Configurations:

```julia
abstols = 1.0 ./ 10.0 .^ (3:2:12)
reltols = 1.0 ./ 10.0 .^ (3:2:12)
```

Helper Functions:

```julia
function check_solver(prob, solver)
    prob.u0 isa StaticArray && solver.pkg === :wrapper && return false
    try
        sol = solve(prob, solver.solver[:alg]; abstol = 1e-5, reltol = 1e-5,
            maxiters = 10000)
        err = norm(sol.resid)
        if !SciMLBase.successful_retcode(sol.retcode)
            Base.printstyled("[Warn] Solver $(solver.name) returned retcode $(sol.retcode) with an residual norm = $(norm(sol.resid)).\n";
                color = :red)
            return false
        elseif err > 1e3
            Base.printstyled("[Warn] Solver $(solver.name) had a very large residual (norm = $(norm(sol.resid))).\n";
                color = :red)
            return false
        elseif isinf(err) || isnan(err)
            Base.printstyled("[Warn] Solver $(solver.name) had a residual of $(err).\n";
                color = :red)
            return false
        end
        Base.printstyled("[Info] Solver $(solver.name) successfully solved the problem (norm = $(norm(sol.resid))).\n";
            color = :green)
    catch e
        Base.printstyled("[Warn] Solver $(solver.name) threw an error: $e.\n"; color = :red)
        return false
    end
    return true
end

function generate_wpset(prob, solvers)
    successful_solvers = filter(solver -> check_solver(prob, solver), solvers)
    return WorkPrecisionSet(prob, abstols, reltols, getfield.(successful_solvers, :solver);
        numruns = 50, error_estimate = :l∞, names = getfield.(successful_solvers, :name),
        maxiters = 10000), successful_solvers
end
```

Plotting Functions:

```julia
# This is hardcoded for 4 input length
function plot_all_wpsets(wpset_list, solver_all, titles, suptitle)
    @assert length(wpset_list) == length(titles) == 4
    LINESTYLES = Dict(:nonlinearsolve => :solid, :simplenonlinearsolve => :dash,
        :wrapper => :dot)
    ASPECT_RATIO = 0.7 #(sqrt(5) - 1) / 2
    WIDTH = 1400 * 2
    HEIGHT = round(Int, WIDTH * ASPECT_RATIO)
    STROKEWIDTH = 2.5

    cycle = Cycle([:color, :marker], covary = true)
    plot_theme = Theme(Lines = (; cycle,), Scatter = (; cycle,))

    fig = with_theme(plot_theme; fontsize = 32) do 
        fig = Figure(; size = (WIDTH, HEIGHT))
        # `textbf` doesn't work
        axs = Matrix{Any}(undef, 2, 2)

        for i in 1:2, j in 1:2
            ylabel = j == 1 ? L"$\mathrm{\mathbf{Time}}$ $\mathbf{(s)}$" : ""
            xlabel = i == 2 ? L"$\mathrm{\mathbf{Error}}$: $\mathbf{f(u^\ast)}$ $\mathbf{L_{\infty}}-\mathrm{\mathbf{norm}}$" : ""
            ax = Axis(fig[i, j]; ylabel = ylabel, title = titles[2 * (i - 1) + j],
                xlabel = xlabel, xticksvisible =  i == 2, yticksvisible = j == 1,
                xticklabelsvisible = i == 2, yticklabelsvisible = j == 1,
                xscale = log10, yscale = log10, xtickwidth = STROKEWIDTH,
                ytickwidth = STROKEWIDTH, titlesize = 36, spinewidth = STROKEWIDTH)
            axs[i, j] = ax
        end

        ls, scs = [], []
        label_list = []

        for (idx_solver, solver) in enumerate(reverse(solver_all))
            first_success = true
            for i in 1:2, j in 1:2
                wpset, successful_solvers = wpset_list[2 * (i - 1) + j]

                idx = findfirst(==(solver.name), [solver.name for solver in successful_solvers])
                idx === nothing && continue

                (; name, times, errors) = wpset.wps[idx]
                errors = [err.l∞ for err in errors]
                l = lines!(axs[i, j], errors, times; linestyle = LINESTYLES[solver.pkg],
                    label = name, linewidth = 3, color = Cycled(idx_solver))
                sc = scatter!(axs[i, j], errors, times; label = name, markersize = 24,
                    strokewidth = 1, marker = Cycled(idx_solver),
                    color = Cycled(idx_solver))

                if first_success
                    push!(ls, l)
                    push!(scs, sc)
                    push!(label_list, solver.name)
                    first_success = false
                end
            end
        end

        linkaxes!(axs...)

        Legend(fig[3, :], collect(reverse([[l, sc] for (l, sc) in zip(ls, scs)])),
            collect(reverse(label_list)),
            "Solvers"; framevisible=true, framewidth = STROKEWIDTH, orientation = :horizontal,
            titlesize = 30, margin = (-85.0, 0.0, 0.0, 0.0), nbanks = 3, labelsize = 20)

        fig[0, :] = Label(fig, suptitle, fontsize = 48, font = :bold)

        fig
    end

    return fig
end
```

## Static Array Versions

```julia
probs = [generate_prob(Val(N), Val(true)) for N in [2, 4, 8, 12]];
wpsets = [generate_wpset(prob, solvers) for prob in probs];
titles = ["N = 2", "N = 4", "N = 8", "N = 12"];

fig = plot_all_wpsets(wpsets, solvers, titles, "Static Arrays")
```

```julia
save("static_arrays_quadratic.svg", fig)
```

## Regular Julia Arrays

```julia
probs = [generate_prob(Val(N), Val(false)) for N in [4, 16, 128, 1024]]
wpsets = [(@show length(prob.u0); generate_wpset(prob, solvers)) for prob in probs]
titles = ["N = 4", "N = 16", "N = 128", "N = 1024"]

fig = plot_all_wpsets(wpsets, solvers, titles, "Regular Julia Arrays")
```

```julia
save("regular_arrays_quadratic.svg", fig)
```

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```
