---
title: Tensor Product Function
author: Chris Rackauckas, Sathvik Bhagavan, Mridul Jain
---

## Tensor Product Function

The tensor product function is defined as:

\[ f(x) =  \prod_{i=1}^{d} \cos(a\pi x_i) \]

where:

- \(d\): Represents the dimensionality of the input vector \(x\).
- \(x_i\): Represents the \(i\)-th component of the input vector.
- \(a\): A constant parameter.

## Import necessary packages

```julia
using Surrogates
using Plots
using Statistics
using SurrogatesRandomForest
using PrettyTables
using BenchmarkTools
default()
```

## Define the function

```julia
function tensor_product_function(x)
    a = 0.5
    return prod(cos.(a * Ï€ * x))
end
```

## Sampling parameters for training and test data

```julia
lb = -5.0  # Lower bound of sampling range
ub = 5.0   # Upper bound of sampling range
n = 100     # Number of training points
```

## Sample training and testing data points

```julia
x_train = sample(n, lb, ub, SobolSample())  # Sample training data points
y_train = tensor_product_function.(x_train)  # Calculate corresponding function values
x_test = sample(150, lb, ub, RandomSample())  # Sample larger test data set
y_test = tensor_product_function.(x_test)  # Calculate corresponding true function values
```

## Plot training and testing points

```julia
scatter(x_train, y_train, label="Training Points", xlabel="X-axis", ylabel="Y-axis", legend=:topright)
scatter!(x_test, y_test, label="Testing Points")
```
## Fit surrogate models

```julia
randomforest_surrogate = RandomForestSurrogate(x_train ,y_train ,lb, ub, num_round = 10)
radial_surrogate = RadialBasis(x_train, y_train, lb, ub)
kriging_surrogate = Kriging(x_train, y_train, lb, ub)
loba_surrogate = LobachevskySurrogate(x_train, y_train, lb, ub, alpha = 2.0, n = 6)
```

## Find the Predictions

```julia
random_forest_pred = randomforest_surrogate.(x_test)
radial_pred = radial_surrogate.(x_test)
kriging_pred = kriging_surrogate.(x_test)
loba_pred = loba_surrogate.(x_test)
```

## Define the MSE function

```julia
function calculate_mse(predictions, true_values)
    return mean((predictions .- true_values).^2)  # Calculate mean of squared errors
end
```

## Calculate MSE for the models

```julia
mse_rf = calculate_mse(random_forest_pred, y_test)
mse_radial = calculate_mse(radial_pred, y_test)
mse_krig = calculate_mse(kriging_pred, y_test)
mse_loba = calculate_mse(loba_pred, y_test)
```

## Display MSE values in a table

```julia
models = ["Random Forest", "Radial Basis", "Kriging", "Lobachevsky"]
train_mses = [calculate_mse(randomforest_surrogate.(x_train), y_train),
              calculate_mse(radial_surrogate.(x_train), y_train),
              calculate_mse(kriging_surrogate.(x_train), y_train),
              calculate_mse(loba_surrogate.(x_train), y_train)]
test_mses = [mse_rf, mse_radial, mse_krig, mse_loba]
pretty_table(hcat(models, train_mses, test_mses), header=["Model", "Training MSE", "Testing MSE"])
```

## Plot predictions against true function

```julia
xs = -5:0.01:5
plot(xs, tensor_product_function.(xs), label="True function", legend=:top, color=:black)
plot!(xs, randomforest_surrogate.(xs), label="Random Forest", legend=:top, color=:green)
plot!(xs, radial_surrogate.(xs), label="Radial Basis", legend=:top, color=:red)
plot!(xs, kriging_surrogate.(xs), label="Kriging", legend=:top, color=:blue)
plot!(xs, loba_surrogate.(xs), label="Lobachevsky", legend=:top, color=:purple)
```

## Time evaluation of models

```julia
num_samples = 10  # Number of samples for timing
time_original = @belapsed tensor_product_function.(x_test)
time_rf = @belapsed randomforest_surrogate.(x_test)
time_radial = @belapsed radial_surrogate.(x_test)
time_krig = @belapsed kriging_surrogate.(x_test)
time_loba = @belapsed loba_surrogate.(x_test)
```

## Sort the times from fastest to slowest and display them in a table

```julia
times = Dict("Random Forest" => time_rf, "Radial Basis" => time_radial, "Kriging" => time_krig, "Lobachevsky" => time_loba, "Original Function" => time_original)
sorted_times = sort(collect(times), by=x->x[2]) # 
models_sorted = [pair[1] for pair in sorted_times]
times_sorted = [pair[2] for pair in sorted_times]
Times_Table = pretty_table(hcat(models_sorted, times_sorted), header=["Model", "Time (s)"])
```
