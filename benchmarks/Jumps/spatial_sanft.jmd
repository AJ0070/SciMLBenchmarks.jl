---
title: Model from Sanft, 2015
author: Vasily Ilin
---

```julia
using DiffEqJump, BenchmarkTools, Plots, Plots.PlotMeasures
gr()
```

# Model description and setup
Here we implement the model from [^1] (8 species and 12 reactions) for different mesh sizes and benchmark the performance of spatial SSAs. The value `linear_num` is the number of subvolumes along one edge of the grid. In [^1] this value ranges from 20 to 60.

```julia
function model_setup(linear_num, end_time)
    
    # species ordering: 1 = E_A, 2 = A, 3 = E_B, 4 = B, 5 = E_A B, 6 = E_A B_2, 7 = E_B A, 8 = E_B A_2
    avogadro = 6.02214076e23
    num_species = 8

    # topology
    domain_size = 12.0e-6 #meters
    mesh_size = domain_size/linear_num
    dims = (linear_num, linear_num, linear_num)
    num_nodes = prod(dims)
    grid = CartesianGrid(dims)

    # reactions
    k_1 = 150
    k_a = 4.62e4 / (avogadro * mesh_size^3)
    k_d = 3.82
    k_4 = 6.0

    reactstoch = [[1 => 1], [3 => 1], [1 => 1, 4 => 1], [5 => 1], [5 => 1, 4 => 1], [6 => 1], [3 => 1, 2 => 1], [7 => 1], [7 => 1, 2 => 1], [8 => 1], [2 => 1], [4 => 1]]

    netstoch = [[2 => 1], [4 => 1], 
    [1 => -1, 4 => -1, 5 =>  1], 
    [1 =>  1, 4 =>  1, 5 => -1], 
    [5 => -1, 4 => -1, 6 =>  1], 
    [5 =>  1, 4 =>  1, 6 => -1], 
    [3 => -1, 2 => -1, 7 =>  1], 
    [3 =>  1, 2 =>  1, 7 => -1], 
    [7 => -1, 2 => -1, 8 =>  1], 
    [7 =>  1, 2 =>  1, 8 => -1], 
    [2 => -1], [4 => -1]]
    rates = [k_1, k_1, k_a, k_d, k_a, k_d, k_a, k_d, k_a, k_d, k_4, k_4]
    @assert length(reactstoch) == length(netstoch) == length(rates)
    majumps = MassActionJump(rates, reactstoch, netstoch)

    # starting state
    total_num = trunc(Int, 12.3e-9 * avogadro * (domain_size*10)^3)
    u0 = zeros(Int, num_species, num_nodes)
    rand_EA = rand(1:num_nodes, total_num)
    rand_EB = rand(1:num_nodes, total_num)
    for i in 1:total_num
        u0[1,rand_EA[i]] += 1
        u0[3,rand_EB[i]] += 1
    end

    # hops
    hopping_rate = 1.0e-12/mesh_size^2
    hopping_constants = hopping_rate * ones(num_species, num_nodes)

    # DiscreteProblem
    prob = DiscreteProblem(u0, (0.0,end_time), rates)

    return prob, majumps, hopping_constants, grid
end
```

# Benchmarking performance of the methods
We run the algorithms and record the performance with `BenchmarkTools`.

```julia
function benchmark_and_save!(bench_dict, end_times, linear_nums, algs)
    @assert length(end_times) == length(linear_nums)

    for (end_time, linear_num) in zip(end_times, linear_nums)
        names = ["$s"[1:end-2] for s in algs]

        @show linear_num
        prob, majumps, hopping_constants, grid = model_setup(linear_num, end_time)

        # benchmarking and saving
        benchmarks = Vector{BenchmarkTools.Trial}(undef, length(algs))

        for (i, alg) in enumerate(algs)
            name = names[i]
            println("benchmarking $name")
            jp = JumpProblem(prob, alg, majumps, hopping_constants=hopping_constants, spatial_system = grid, save_positions=(false,false))
            solve(jp, SSAStepper())
            b = @benchmarkable solve($jp, SSAStepper()) samples = 1 seconds = 1500
            bench_dict[name, linear_num] = run(b)
        end
    end
end
```

# Plotting
Plot the benchmarking data.

```julia
function fetch_and_plot(bench_dict)
    names = unique([key[1] for key in keys(bench_dict)])
    linear_nums = sort(unique([key[2] for key in keys(bench_dict)]))

    plt1 = plot()
    plt2 = plot()

    medtimes = [Float64[] for i in 1:length(names)]
    for (i,name) in enumerate(names)
        for linear_num in linear_nums
            try
                push!(medtimes[i], median(bench_dict[name, linear_num]).time/1e9)
            catch
                break
            end
        end
        len = length(medtimes[i])
        plot!(plt1, linear_nums[1:len], medtimes[i], marker = :hex, label = name)
        plot!(plt2, (linear_nums.^3)[1:len], medtimes[i], marker = :hex, label = name)
    end

    ylabel!(plt1, "median time in seconds")
    xlabel!(plt1, "number of sites per edge")
    title!(plt1, "3D RDME")
    xticks!(plt1, linear_nums)

    ylabel!(plt2, "median time in seconds")
    xlabel!(plt2, "total number of sites")
    title!(plt2, "3D RDME")
    xticks!(plt2, (linear_nums.^3, string.(linear_nums.^3)) )
    
    plot(plt1, plt2, size = (1200,800), margin = 10mm, legendtitle = "SSAs")
end
```

```julia
algs = [NSM(), DirectCRDirect(), DirectCR(), RSSACR()]
end_times = [16.0, 9.3, 5.8, 3.9] # for ≈ 10^8 jumps
end_times = 0.00001*ones(2) # for ≈ 10^8 jumps
linear_nums = [20, 30]
bench_dict = Dict{Tuple{String, Int}, BenchmarkTools.Trial}()
benchmark_and_save!(bench_dict, end_times, linear_nums, algs)

algs = [NSM(), DirectCRDirect()]
end_times = [2.8] # for ≈ 10^8 jumps
end_times = 0.00001*[1.0]
linear_nums = [60]
benchmark_and_save!(bench_dict, end_times, linear_nums, algs)
```

```julia
plt=fetch_and_plot(bench_dict)
```

# References

[^1]: Sanft, Kevin R and Othmer, Hans G. Constant-complexity stochastic simulation algorithm with optimal binning”. In: _The Journal of chemical physics_ 143.7 (2015), pp. 08B609\_1.

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```