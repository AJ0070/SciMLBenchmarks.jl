---
title: RC Circuit
author: Yingbo Ma, Chris Elrod
---

When a model is defined using repeated components, JuliaSimCompiler is able to take advantage of this to scale efficiently by rerolling equations into loops. This option can be disabled by setting `loop=false`. Here, we build an RC circuit model with variable numbers of components to show scaling of compile and runtimes of MTK vs JuliaSimCompiler's three backends with and without loop rerolling.
```julia
using JuliaSimCompiler, ModelingToolkit, BenchmarkTools, ModelingToolkitStandardLibrary, CairoMakie
using ModelingToolkitStandardLibrary.Blocks
using ModelingToolkitStandardLibrary.Electrical

const t = Blocks.t

function build_system(n)
  systems = @named begin
    sine = Sine(frequency = 10)
    source = Voltage()
    resistors[1:n] = Resistor()
    capacitors[1:n] = Capacitor()
    ground = Ground()
  end
  systems = reduce(vcat, systems)
  eqs = [connect(sine.output, source.V)
       connect(source.p, resistors[1].p)
       [connect(resistors[i].n, resistors[i + 1].p, capacitors[i].p)
        for i in 1:(n - 1)]
       connect(resistors[end].n, capacitors[end].p)
       [connect(capacitors[i].n, source.n) for i in 1:n]
       connect(source.n, ground.g)]
  @named sys = ODESystem(eqs, t; systems)
  u0 = [capacitors[i].v => float(i) for i in 1:n];
  ps = [[resistors[i].R => 1 / i for i in 1:n];
        [capacitors[i].C => 1 / i^2 for i in 1:n]]
  return sys, u0, ps
end

function compile_run_problem(sys, u0, ps; target=JuliaSimCompiler.JuliaTarget())
  tspan = (0.0, 10.0)
  t0 = time()
  if target === JuliaSimCompiler.JuliaTarget()
    prob = ODEProblem(sys, u0, tspan, ps)
  else
    prob = ODEProblem(sys, target, u0, tspan, ps)
  end
  (; f, u0, p) = prob
  ff = f.f
  u0 .= 12.0
  du = similar(u0)
  ff(du, u0, p, 0.0)
  t_fode = time() - t0
  t_run = @belapsed $ff($du, $u0, $p, 0.0)
  t_fode, t_run
end

const C = JuliaSimCompiler.CTarget();
const LLVM = JuliaSimCompiler.llvm.LLVMTarget();

function run_and_time!(ss_times, times, max_sizes, i, n)
  sys, u0, ps = build_system(n)
  if n <= max_sizes[1]
    ss_times[i, 1] = @elapsed sys_mtk = structural_simplify(sys)
    times[i, 1] = compile_run_problem(sys_mtk, u0, ps)
  end
  t_cce = @elapsed ir_state = JuliaSimCompiler.compressed_connection_expansion(sys)
  ss_times[i, 2] = t_cce + @elapsed sys_jsir_scalar = structural_simplify(ir_state, loop=false)
  ss_times[i, 3] = t_cce + @elapsed sys_jsir_loop = structural_simplify(ir_state)
  n <= max_sizes[2] && (times[i, 2] = compile_run_problem(sys_jsir_scalar, u0, ps))
  n <= max_sizes[3] && (times[i, 3] = compile_run_problem(sys_jsir_scalar, u0, ps, target=C))
  n <= max_sizes[4] && (times[i, 4] = compile_run_problem(sys_jsir_scalar, u0, ps, target=LLVM))
  n <= max_sizes[5] && (times[i, 5] = compile_run_problem(sys_jsir_loop, u0, ps))
  n <= max_sizes[6] && (times[i, 6] = compile_run_problem(sys_jsir_loop, u0, ps, target=C))
  n <= max_sizes[7] && (times[i, 7] = compile_run_problem(sys_jsir_loop, u0, ps, target=LLVM))
  @show n, ss_times[i, :], times[i, :]
end

N = vcat([5, 10, 20, 40, 60, 80, 160, 320, 480, 640, 800], 1_000:1_000:10_000);

# max size we test per method
max_sizes = [1000, 10_000, 10_000, 10_000, 10_000, 10_000, 10_000];

# NaN-initialize so Makie will ignore incomplete
ss_times = fill(NaN, length(N), 3);
times = fill((NaN,NaN), length(N), length(max_sizes));

@time run_and_time!(ss_times, times, max_sizes, 1, 4); # precompile

for (i, n) in enumerate(N)
  run_and_time!(ss_times, times, max_sizes, i, n)
end

f = Figure();
let ax = Axis(f[1, 1]; title="Structural Simplify Time")
  for (j, label) in enumerate(("MTK", "JSIR-Scalar", "JSIR-Loop"))
    ts = @view(ss_times[:, j])
    lines!(N, ts; label)
  end
  axislegend(ax)
end
for (i, timecat) in enumerate(("ODEProblem + f!", "Run"))
  title = timecat * " Time"
  ax = Axis(f[i+1, 1]; title)
  for (j, label) in enumerate(("MTK", "JSIR - Scalar - Julia", "JSIR - Scalar - C", "JSIR - Scalar - LLVM", "JSIR - Loop - Julia", "JSIR - Loop - C", "JSIR - Loop - LLVM"))
    ts = getindex.(@view(times[:, j]), i)
    lines!(N, ts; label)
  end
  axislegend(ax)
end
f
```
All three backends compiled more quickly with loops, but the C and LLVM backends are so much quicker to compile than the Julia backend that this made much less difference for them.
The impact on runtime was more varied.

## Appendix

```julia, echo = false
using SciMLBenchmarks
SciMLBenchmarks.bench_footer(WEAVE_ARGS[:folder],WEAVE_ARGS[:file])
```

