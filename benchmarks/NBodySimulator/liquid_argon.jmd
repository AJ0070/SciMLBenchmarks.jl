---
title: Liquid argon benchmarks
author: Sebastian Micluța-Câmpeanu, Mikhail Vaganov
---

```julia
using BenchmarkTools
using NBodySimulator, OrdinaryDiffEq, StaticArrays
using Plots, DataFrames, StatsPlots

function setup(t)
    T = 120.0 # K
    kb = 1.38e-23 # J/K
    ϵ = T * kb # J
    σ = 3.4e-10 # m
    ρ = 1374 # kg/m^3
    m = 39.95 * 1.6747 * 1e-27 # kg
    N = 216
    L = (m*N/ρ)^(1/3)
    R = 0.5L
    v_dev = sqrt(kb * T / m) # m/s

    bodies = generate_bodies_in_cell_nodes(N, m, v_dev, L)
    lj_parameters = LennardJonesParameters(ϵ, σ, R)
    pbc = CubicPeriodicBoundaryConditions(L)
    lj_system = PotentialNBodySystem(bodies, Dict(:lennard_jones => lj_parameters));
    simulation = NBodySimulation(lj_system, (0.0, t), pbc)

    return simulation
end

function benchmark_sim(simulation, alg, τ)
    @info "Benchmarking $alg"
    run_simulation(simulation, alg(), dt=τ, save_everystep=false)
end

function benchmark_setup(SUITE, EnergyError, nt, nf, τ, n, ns;
                        integrators=[VelocityVerlet, Tsit5, DPRKN6, Yoshida6])
    for alg in integrators
        simulation = setup(n*τ)
        b = @benchmarkable benchmark_sim($simulation, $alg, $τ) samples=ns
        result = run_simulation(simulation, alg(), dt=τ, save_everystep=false)
        ΔE = total_energy(result, n*τ) - total_energy(result, 0)

        EnergyError[alg] = ΔE
        nt[alg] = result.solution.destats.naccept
        nf[alg] = result.solution.destats.nf + result.solution.destats.nf2

        SUITE["$alg"] = b
    end
end
```

First we well take a timestep and vary the number of total steps. For adaptive
integrators, this timestep will be the initial timestep.
```julia
τ = 1e-14  # s
results = DataFrame(:integrator=>String[], :sim_time=>Float64[], :runtime=>[],
    :EnergyError=>Float64[],:timesteps=>Int[], :f_evals=>Int[]);
```

We will consider the following integrators
```julia
integrators=[VelocityVerlet, Tsit5, DPRKN6, Yoshida6]
```

Now, let us run the benchmarks
```julia
for n in 10 .^range(2, 5, length=7)
    SUITE = BenchmarkGroup()
    ΔE = Dict()
    nt = Dict()
    nf = Dict()

    benchmark_setup(SUITE, ΔE, nt, nf, τ, n, n < 1e4 ? 5 : 1)
    r = run(SUITE, seconds=200)

    for (k,v) in ΔE
        push!(results, [string(k), n*τ, minimum(r["$k"]), abs(v), nt[k], nf[k]])
    end
end
```

Let us now examine the results
```julia
results
```

First, we will look at the behavior energy error as simulation time (and runtime) increases
```julia
@df results plot(:EnergyError, time.(:runtime)/1e6, group=:integrator,
    xscale=:log10, yscale=:log10, xlabel="Energy error", ylabel="Runtime (ms)")
```

If we consider the number of timesteps instead, we obtain
```julia
@df results plot(:EnergyError, :timesteps, group=:integrator,
    xscale=:log10, yscale=:log10, xlabel="Energy error", ylabel="Number of timesteps")
```
and we can also see how the muber of acceleration function calls affects the runtime
```julia
@df results plot(:f_evals, time.(:runtime)/1e6, group=:integrator,
    xscale=:log10, yscale=:log10, xlabel="Number of f calls", ylabel="Runtime (ms)")
```

Now, let us consider a fixed simulation time
```julia
t = 1e-10
results = DataFrame(:integrator=>String[], :initial_τ=>Float64[], :runtime=>[],
    :EnergyError=>Float64[],:timesteps=>Int[], :f_evals=>Int[]);
```
and change the timesteps
```julia
for τ in 10 .^range(-15, -13, length=5)
    SUITE = BenchmarkGroup()
    ΔE = Dict()
    nt = Dict()
    nf = Dict()

    benchmark_setup(SUITE, ΔE, nt, nf, τ, t/τ, 1)
    r = run(SUITE, seconds=200)

    for (k,v) in ΔE
        push!(results, [string(k), τ, minimum(r["$k"]), abs(v), nt[k], nf[k]])
    end
end
```

Let us now examine the results
```julia
results
```


```julia
@df results plot(:EnergyError, time.(:runtime)/1e6, group=:integrator,
    xscale=:log10, yscale=:log10, xlabel="Energy error", ylabel="Runtime (ms)")
```
